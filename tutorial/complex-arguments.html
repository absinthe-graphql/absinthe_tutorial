<h1 id="complex-arguments">Complex Arguments</h1>
<p>In preparation for supporting comments on our blog, let's create users. We're building a modern mobile first blog of course, and thus want to support either a phone number or an email as the contact method for a user.</p>
<p>We want to support the following mutations.</p>
<p>Support creation of a user with their email address:</p>
<pre class="graphql"><code>mutation CreateEmailUser {
  createUser(contact: {type: EMAIL, value: &quot;foo@bar.com&quot;}, name: &quot;Jane&quot;, password: &quot;hunter1&quot;) {
    id
    contacts {
      type
      value
    }
  }
}</code></pre>
<p>And by using their phone number:</p>
<pre class="graphql"><code>mutation CreatePhoneUser {
  createUser(contact: {type: PHONE, value: &quot;+1 123 5551212&quot;}, name: &quot;Joe&quot;, password: &quot;hunter2&quot;) {
    id
    contacts {
      type
      value
    }
  }
}</code></pre>
<p>To do this we need the ability to create nested arguments. GraphQL has input objects for this purpose. Input objects, like regular object, contain key value pairs, but they are intended for input only (you can't do circular references with them for example).</p>
<p>Another notion we'll look at here is an enumerable type. We only want to support contact types <code>&quot;email&quot;</code> and <code>&quot;phone&quot;</code> at the moment, and GraphQL gives us the ability to specify this in our schema.</p>
<p>Let's start with our <code>:contact_type</code> Enum. In <code>blog_web/schema/account_types.ex</code>:</p>
<pre class="graphql"><code>enum :contact_type do
  value :phone, as: &quot;phone&quot;
  value :email, as: &quot;email&quot;
end</code></pre>
<p>We're using the <code>:as</code> option here to make sure the parsed enum is represented by a string when it's passed to our controllers; this is to ease integration with our Ecto schema (by default, the enum values are passed as atoms).</p>
<blockquote>
<p>The standard convention for representing incoming enum values in GraphQL documents are in all caps. For instance, given our settings here, the accepted values would be <code>PHONE</code> and <code>EMAIL</code> (without quotes). See the GraphQL document examples above for examples.</p>
<p>While the <code>enum</code> macro supports configuring this incoming format, we highly recommend you just use the GraphQL convention.</p>
</blockquote>
<p>Now if a user tries to send some other kind of contact type they'll get a nice error without any extra effort on your part. Enum types are not a substitute for modeling layer validations however, be sure to still enforce things like this on that layer too.</p>
<p>Now for our contact input object.</p>
<p>In <code>blog_web/schema/account_types.ex</code>:</p>
<pre class="graphql"><code>input_object :contact_input do
  field :type, non_null(:contact_type)
  field :value, non_null(:string)
end</code></pre>
<p>Note that we name this type <code>:contact_input</code>. Input object types have their own names, and the <code>_input</code> suffix is common.</p>
<blockquote>
<p>Important: It's very important to remember that only input types---basically scalars and input objects---can be used to model input.</p>
</blockquote>
<p>Finally our schema, in <code>blog_web/schema.ex</code>:</p>
<pre class="elixir"><code>mutation do

  #... other mutations

  @desc &quot;Create a user&quot;
  field :create_user, :user do
    arg :name, non_null(:string)
    arg :contact, non_null(:contact_input)
    arg :password, non_null(:string)

    resolve &amp;Resolvers.Accounts.create_user/3
  end

end</code></pre>
<p>Suppose in our database that we store contact information in a different database table. Our mutation would be used to create both records in this case.</p>
<p>There does not need to be a one to one correspondence between how data is structured in your underlying data store and how things are presented by your GraphQL API.</p>
<p>Our resolver, <code>blog_web/resolvers/accounts.ex</code> might look something like this:</p>
<pre class="elixir"><code>def create_user(_parent, args, %{context: %{current_user: %{admin: true}}}) do
  Blog.Accounts.create_user(args)
end
def create_user(_parent, args, _resolution) do
  {:error, &quot;Access denied&quot;}
end</code></pre>
<p>You'll notice we're checking for <code>:current_user</code> again in our Absinthe context, just as we did before for posts. In this case we're taking the authorization check a step further and verifying that only administrators (in this simple example, an administrator is a user account with <code>:admin</code> set to <code>true</code>) can create a user.</p>
<p>Everyone else gets an <code>&quot;Access denied&quot;</code> error for this field.</p>
<blockquote>
<p>To see the Ecto-related implementation of the <code>Blog.Accounts.create_user/1</code> function and the (stubbed) authentication logic we're using for this example, see the <a href="https://github.com/absinthe-graphql/absinthe_tutorial">absinthe_tutorial</a> repository.</p>
</blockquote>
<p>Here's our mutation in action in GraphiQL.</p>
<p><img style="box-shadow: 0 0 6px #ccc;" src="assets/tutorial/graphiql_create_user.png" alt=""/></p>
<blockquote>
<p>Note we're sending a <code>Authorization</code> header to authenticate, which a plug is handling. Make sure to read the related <a href="context-and-authentication.html">guide</a> for more information on how to set-up authentication in your own applications.</p>
<p>Our simple tutorial application is just using a simple stub: any authorization token logs you in the first user. Obviously not what you want in production!</p>
</blockquote>
<h2 id="next-step">Next Step</h2>
<p>Now let's <a href="conclusion.html">wrap things up</a>.</p>
