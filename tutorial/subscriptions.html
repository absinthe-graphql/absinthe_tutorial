<h1 id="subscriptions">Subscriptions</h1>
<p>When the need arises for near realtime data GraphQL provides subscriptions. We want to support subscriptions that look like</p>
<pre class="graphql"><code>subscription{
  newPost {
    id
    name
  }
}</code></pre>
<p>Since we had already setup mutations to handle creation of posts we can use that as the event we want to subscribe to. In order to achieve this we have to do a little bit of set up</p>
<p>Let's start by adding <code>absinthe_phoenix</code> as a dependency</p>
<p>In <code>mix.exs</code></p>
<pre class="elixir"><code>defp deps do
  [
    {:absinthe_phoenix, &quot;~&gt; 1.4.0&quot;}
    &lt;&lt; other deps &gt;&gt;
  ]</code></pre>
<p>Then we need to add a supervisor to run some processes for the to handle result broadcasts</p>
<p>In <code>lib/blog/application.ex</code>:</p>
<pre class="elixir"><code>  children = [
    # other children ...
    {BlogWeb.Endpoint, []}, # this line should already exist
    {Absinthe.Subscription, [BlogWeb.Endpoint]}, # add this line
    # other children ...
  ]</code></pre>
<p>The lets add a configuration to the phoenix endpoint so it can provide some callbacks Absinthe expects, please note while this guide uses phoenix. Absinthe's support for Subscriptions is good enough to be used without websockets even without a browser.</p>
<p>In <code>lib/blog_web/endpoint.ex</code>:</p>
<pre class="elixir"><code>defmodule BlogWeb.Endpoint do
  use Phoenix.Endpoint, otp_app: :blog # this line should already exist 
  use Absinthe.Phoenix.Endpoint # add this line

  &lt;&lt; rest of the file&gt;&gt;</code></pre>
<p>The <code>PubSub</code> stuff is now set up, let's configure our sockets</p>
<p>In <code>lib/blog_web/channels/user_socket.ex</code></p>
<pre class="elixir"><code>defmodule BlogWeb.UserSocket do
  use Phoenix.Socket # this line should already exist
  use Absinthe.Phoenix.Socket, schema: BlogWeb.Schema # add

  &lt;&lt; rest of file&gt;&gt;</code></pre>
<p>Lets now configure GraphQL to use this Socket.</p>
<p>In <code>lib/blog_web/router.ex</code> :</p>
<pre class="elixir"><code>defmodule BlogWeb.Router do
  use BlogWeb, :router

  pipeline :api do
    plug :accepts, [&quot;json&quot;]
    plug BlogWeb.Context
  end

  scope &quot;/api&quot; do
    pipe_through :api

    forward &quot;/graphiql&quot;, Absinthe.Plug.GraphiQL,
      schema: BlogWeb.Schema,
      socket: BlogWeb.UserSocket # add this line


    forward &quot;/&quot;, Absinthe.Plug,
      schema: BlogWeb.Schema
  end

end</code></pre>
<p>Now let/s set up a subscription root object in our Schema to listen for an event. For this subscription we can set it up to listen every time a new post is created.</p>
<p>In <code>blog_web/schema.ex</code> :</p>
<pre class="elixir"><code>
subscription do

  field :new_post, :post do
    config fn _args, _info -&gt;
      {:ok, topic: &quot;*&quot;}
    end
  end

end</code></pre>
<p>The <code>new_post</code> field is a pretty regular field only new thing here is the <code>config</code> macro, this is here to help us know which clients have subscribed to which fields. Much like WebSockets subscriptions work by allowing t a client to subscribe to a topic.</p>
<p>Topics are scoped to a field and for now we shall use <code>*</code> to indicate we care about all the posts, and that's it!</p>
<p>If you ran the request at this moment you would get a nice message telling you that your subscriptions will appear once after they are published but you create a post and alas! no data what cut?</p>
<p>Once a subscription is set up it waits for a target event to get published in order for us to collect this information we need to publish to this subscription</p>
<p>In <code>blog_web/resolvers/content.ex</code>:</p>
<pre class="elixir"><code>def create_post(_parent, args, %{context: %{current_user: user}}) do
    # Blog.Content.create_post(user, args)
    case Blog.Content.create_post(user, args) do
      {:ok, post} -&gt;
        # add this line in
        Absinthe.Subscription.publish(BlogWeb.Endpoint, post,
        new_post: &quot;*&quot;
        )

        {:ok, post}
      {:error, changeset} -&gt;
        {:ok, &quot;error&quot;}
      end
  end</code></pre>
<p>With this, open a tab and run the query at the top of this section. Then open another tab and run a mutation to add a post you should see a result in the other tab have fun.</p>
<p><img style="box-shadow: 0 0 6px #ccc;" src="assets/tutorial/graphiql_new_post_sub.png" alt=""/></p>
